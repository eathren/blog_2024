---
publishDate: 2023-01-02T00:00:00Z
title: 'Returning Data in Rust with Axum and SeaORM: A Guide and Common Pitfalls'
excerpt: Axum is a wonderful web framework that suffers from incomplete documentation. This is how to actually use some parts of it that are more confusing.
tags:
  - rust
  - axum
  - postgres
  - sea-orm
  - backend
---

# Returning Data in Rust with Axum and SeaORM: A Guide and Pitfalls

Rust's focus on memory safety and performance makes it an increasingly popular choice for backend development.
When working with frameworks like **Axum** and ORMs like **SeaORM**, understanding how to return data is essential for building web applications effectively.
In this post, we'll explore how to return data using these tools, tackle common pitfalls, and discuss some best practices.

## Setting Up Axum

Axum is a web framework built on **hyper**. It's known for its flexibility and powerful features,
allowing you to easily define routes and return data.

```toml
# Cargo.toml
[dependencies]
axum = "0.6"
tokio = { version = "1", features = ["full"] }
sea-orm = { version = "1.0.1", features = ["sqlx-postgres"] }
```

### Basic Axum Example

```rust
use axum::{routing::get, Router};
use std::net::SocketAddr;

#[tokio::main]
async fn main() {
    // Define a route and handler
    let app = Router::new().route("/", get(handler));

    // Start the server
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("Listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn handler() -> &'static str {
    "Hello, world!"
}
```

In this example, `handler` simply returns a static string. But what if we want to return more complex data?

## Returning JSON in Axum

Axum makes it simple to return JSON responses. You just need to return a `Json<T>` type.

```rust
use axum::{response::Json, routing::get, Router};
use serde::Serialize;
use std::net::SocketAddr;

#[derive(Serialize)]
struct ResponseData {
    message: String,
}

async fn json_handler() -> Json<ResponseData> {
    Json(ResponseData {
        message: "Hello, world!".to_string(),
    })
}

#[tokio::main]
async fn main() {
    let app = Router::new().route("/", get(json_handler));

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("Listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

Now, the handler returns a JSON response with a `message` field.

## Integrating SeaORM with Axum

SeaORM is a powerful and asynchronous ORM that fits well with Axum. Let's walk through an example where we return data from a PostgreSQL database using SeaORM.

First, make sure your `Cargo.toml` includes:

```toml
sea-orm = { version = "0.9", features = ["sqlx-postgres"] }
```

### Example: Fetching Data from the Database

```rust
use axum::{extract::Path, response::Json, routing::get, Router};
use sea_orm::{Database, EntityTrait, QueryFilter};
use serde::Serialize;
use std::net::SocketAddr;
use entity::prelude::*;

#[derive(Serialize)]
struct UserResponse {
    id: i32,
    email: String,
}

async fn get_user(Path(id): Path<i32>, db: DatabaseConnection) -> Json<UserResponse> {
    let user = Users::find_by_id(id).one(&db).await.unwrap();

    if let Some(user) = user {
        Json(UserResponse {
            id: user.id,
            email: user.email,
        })
    } else {
        Json(UserResponse {
            id: 0,
            email: "Not found".to_string(),
        })
    }
}

#[tokio::main]
async fn main() {
    let database_url = "postgres://username:password@localhost/db";
    let db = Database::connect(database_url).await.unwrap();

    let app = Router::new()
        .route("/user/:id", get(get_user))
        .layer(axum::AddExtensionLayer::new(db));

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("Listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

In this example, we define a `get_user` function that fetches a user from the database using SeaORM and returns it as JSON.

### Common Pitfalls

1. **Database Connections**: Always ensure that you manage your database connections efficiently. Using a connection pool can prevent performance issues.
2. **Error Handling**: Rust's error handling can sometimes be verbose. Consider using libraries like `thiserror` to simplify returning errors.
3. **Lifetime Issues**: When working with complex data types, be mindful of Rust's ownership rules and lifetimes. Lifetimes can cause issues when you try to return data that doesnâ€™t live long enough, especially in database operations.

### Conclusion

Returning data in Rust using Axum and SeaORM is powerful and flexible. By understanding how to structure your routes and return types, you can build fast and reliable web applications. Keep an eye out for common pitfalls like managing database connections and handling errors gracefully.
